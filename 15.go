//15. К каким негативным последствиям может привести данный фрагмент кода,
//и как это исправить? Приведите корректный пример реализации.
//
//var justString string
//
//func someFunc() {
//v := createHugeString(1 << 10)
//justString = v[:100]
//}
//
//func main() {
//someFunc()
//}

package main

import (
	"errors"
	"fmt"
	"strings"
)

// Данный выше фрагмент кода создает очень большую строку и записывает значение в глобальную переменную
//
// 1) создается очень большая строка, которая записывается в глобальную переменную.
// глобальные переменные, на равне с указателями, хранятся в куче, поэтому помещение переменной такого объема
// в кучу может как вызвать проблемы с очисткой кучи, так и вовсе исчерпать память.
// один из вариантов - сделать justString локальной (конечно это зависит от того, как она будет использоваться)
// и по возможности пользоваться ее копией, которую мы передаем в функцию. такие переменные хранятся в стэке
//
// 2) мы точно не знаем, что делает функция createHugeString, поэтому после создания среза строки
// в записи v[:100] мы можем случайно выйти за пределы строки,
// ведь на самом деле элементов там может быть меньше, чем 100
//
//3) также можно более явно описать, что делает функция, и добавить возвращаемый элемент вместо переназначения
//так функция и ее использование будет более выразительно

func main() {
	// делаем переменные
	var justString string
	var err error
	// обрабатываем ошибку и записываем значение если все ок
	justString, err = someFunc()
	if err != nil {
		fmt.Printf("%v\n", err)
		return
	}
	fmt.Println(justString)
}

// более выразительная функция somefunc
func someFunc() (string, error) {
	v := createHugeString(1 << 10)
	if len(v) < 100 {
		fmt.Printf("Error! The length of the string should be > 100")
		return "", errors.New("String too small")
	}
	return v[:100], nil
}

// мое представление того,как может выглядеть ф-ия createHugeString
func createHugeString(length int) string {
	strBuilder := strings.Builder{}
	for range length {
		strBuilder.WriteString("f")
	}
	return strBuilder.String()
}
