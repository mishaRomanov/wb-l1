// 17. Реализовать бинарный поиск встроенными методами языка
package main

import (
	"fmt"
	"slices"
)

// сама функция
func bsearch(list []int, goal int) bool {
	// бинарный поиск работает только с отсортированными массивами, поэтому проверяем, отсортирован ли он
	// естественно, никто так делать не будет, просто захотелось добавить... в таком случае уж логичнее было бы отсортировать его
	if !slices.IsSorted(list) {
		fmt.Println("Slice is not sorted.")
		return false
	}
	// объявляем средний элемент, наибольший и наименьший элементы
	var (
		min int = 0
		max int = len(list) - 1
		mid int
	)

	// запускаем цикл. он работает, пока минимальное число меньше либо рано большему
	for min <= max {
		// вычисляем середину
		mid = (min + max) / 2
		// проверяем, равен ли серединный элемент
		if list[mid] == goal {
			return true
			// если серединное число больше цели, максимальным числом делаем его минус один (на случай если оно действительно было меньше цели на 1)
		} else if list[mid] > goal {
			max = mid - 1
			// если серединное число меньше цели, минимальным числом делаем его плюс один по той же логике
		} else if list[mid] < goal {
			min = mid + 1
		}
	}
	// возвращаем если не найдено
	return false
}

// тест бинарного поиска
func main() {
	var list []int

	for n := range 50 {
		list = append(list, n)
	}

	fmt.Println(bsearch(list, 25))
	fmt.Println(bsearch(list, 155))

	// тест кейс для неотсортированного массива
	fmt.Println(bsearch([]int{555, 1, 2, 3, 67, 0}, 25))
}
